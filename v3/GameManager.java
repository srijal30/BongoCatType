import java.util.LinkedList;;

public class GameManager {
    private LinkedList<Character> inputQ; //stores user inputted texts
    private LinkedList<Character> textQ; //stores texts generated by WordGenerator
    
    private long startTime;
    
    private double rawWPM;
    private double realWPM;
    private double accuracy;

    public double getRawWPM(){ return rawWPM; }
    public double getRealWPM(){ return realWPM; }
    public double getAccuracy(){ return accuracy; }
    public String getText( int start ){ //get the real words starting from specific index
        String result = "";
        for( int i = start; i < textQ.size(); i++ ) result += textQ.get(i);
        return result;
    }
    public String getInput(){
        String result = "";
        for( char c : inputQ ) result += c;
        return result;
    }

    public GameManager(){ //we technically dont need this
    }
    //creates new text based on wordCount
    //in the future allow repeats of texts (maybe store previous texts somewhere)
    public void newGame( int wordCount ){
        //reset vals of old game
        rawWPM = realWPM = accuracy = 0;
        inputQ = new LinkedList<>();
        textQ = new LinkedList<>();
        //generate new words
        String prompt = WordGenerator.generate( wordCount );
        //loop through every char (except last one which is an extra space)
        for( int i = 0; i < prompt.length()-1; i++ ) textQ.add( prompt.charAt(i) );
    }
    public void startTimer(){
        startTime = System.nanoTime();
    }
    //returns true or false depending on wheter the char is right
    public boolean pushCharacter( char c ){
        inputQ.add( c );
        //if size cap is reached, then always wrong
        if( inputQ.size() > textQ.size() ) return false;
        //check if the latest chars added match
        //in the future maybe utilize a enqueue-dequeue
        return inputQ.getLast().equals( textQ.get(inputQ.size()-1) );
    }
    //called when user presses "backspace" or something similar
    //not sure if the return is necassary, but returns whether it is possible to remove Char
    public boolean removeCharacter(){
        if( inputQ.isEmpty() ) return false;
        inputQ.removeLast();
        return true;
    }
    //updates all the stats (realWPM, accuracy, and rawWPM)
    //up to the game instance how often they call this function
    //if returns true, the game is over
    public boolean update(){
        if( inputQ.size() > textQ.size() ){
            return true;
        }
        //if not possible to update then ignore this call
        if( inputQ.isEmpty() ) return false;
        double timePassed = ( System.nanoTime() - startTime ) / 60.0 / 1000000000.0 ; //in minutess
        //calc the raw
        rawWPM = (inputQ.size() / 5.0) / timePassed;
        //loop through the new chars, finding mistakes
        int mistakes = 0;
        for( int i = 0; i < inputQ.size(); i++ ){
            //if inputQ size surpasses textQ size, then always a mistake
            if( i >= textQ.size() ){
                mistakes++;
            }
            //if they dont match, also incremement
            if( !inputQ.get( i ).equals( textQ.get( i ) ) ){
                mistakes++;
            }
        }
        //calc real and accuracy
        realWPM =  ((inputQ.size() - mistakes)/ 5.0) / timePassed;
        accuracy = (inputQ.size() - mistakes) / (double)inputQ.size();
        return false;
    }
}
