import java.util.LinkedList;;

public class GameManager {
    private LinkedList<Character> inputQ; //stores user inputted texts
    private LinkedList<Character> realQ; //stores texts generated by WordGenerator
    private String text;
    
    private long startTime;
    private int mistakes;
    
    private double rawWPM;
    private double realWPM;
    private double accuracy;

    public double getRawWPM(){ return rawWPM; }
    public double getRealWPM(){ return realWPM; }
    public double getAccuracy(){ return accuracy; }
    public String getText(){ return text; }

    public GameManager(){ //we technically dont need this
        rawWPM = realWPM = accuracy = mistakes = 0;
        inputQ = new LinkedList<>();
        realQ = new LinkedList<>();
    }
    //creates new text based on wordCount
    //in the future allow repeats of texts (maybe store previous texts somewhere)
    public void newGame( int wordCount ){
        //reset vals of old game
        rawWPM = realWPM = accuracy = mistakes = 0;
        inputQ = new LinkedList<>();
        realQ = new LinkedList<>();
        //generate new words
        text = WordGenerator.generate( wordCount );
        //loop through every char (except last one which is an extra space)
        for( int i = 0; i < text.length()-1; i++ ) realQ.add( text.charAt(i) );
    }
    public void startTimer(){
        startTime = System.nanoTime();
    }
    //returns true or false depending on wheter the char is right
    public boolean pushCharacter( char c ){
        inputQ.add( c );
        //if size cap is reached, then always wrong
        if( inputQ.size() > realQ.size() ) return false;
        //check if the latest chars added match
        //in the future maybe utilize a enqueue-dequeue
        return inputQ.getLast().equals( realQ.get(inputQ.size()) );
    }
    //called when user presses "backspace" or something similar
    //not sure if the return is necassary, but returns whether it is possible to remove Char
    public boolean removeCharacter(){
        if( inputQ.isEmpty() ) return false;
        inputQ.removeLast();
        return true;
    }
    //updates all the stats (realWPM, accuracy, and rawWPM)
    //up to the game instance how often they call this function
    public void update(){
        //if not possible to update then ignore this call
        if( inputQ.isEmpty() ) return;

        double timePassed = ( System.nanoTime() - startTime ) / 60.0 / 1000000000.0; //in minutes
        //calc the raw
        rawWPM = (inputQ.size() / 5.0) / timePassed;
        //loop through the new chars, finding mistakes
        for( int i = 0; i < inputQ.size(); i++ ){
            //if inputQ size surpasses realQ size, then always a mistake
            if( i >= realQ.size() ){
                mistakes++;
            }
            //if they dont match, also incremement
            if( !inputQ.get( i ).equals( realQ.get( i ) ) ){
                mistakes++;
            }
        }
        //calc real and accuracy
        realWPM =  ((inputQ.size() - mistakes)/ 5.0) / timePassed;
        accuracy = (inputQ.size() - mistakes) / inputQ.size();
    }
}
